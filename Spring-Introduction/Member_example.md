*회원 웹 기능 -> 홈 화면 추가*

Welcome Page에서도 먼저 Controller를 보고 mapping된 것이 있는지 확인을 하고
"/"로 mapping이 된게 있으니까, return 값을 보고
home.html로 가서 Welcome Page를 띄움

---궁금한 점---
"/" 가 왜 mapping이 되는 건지??
여기서도 Controller 3개가 다 올라가 있는건가?

index.html에서 사용된다고 했는데, 이건 Controller가 없을때만 사용되는 것

return 값인 template/home.html로 이동.
그 안의 /members/new , /members는 그 링크로 이동하라는 뜻.

localhost:8080에 들어가서 회원가입을 누르면 localhost:8080/members/new 링크로 이동.
또 MemberController에 있는 
@GetMapping("/members/new")에 매칭이 되서, return 값인
members/createMemberForm.html로 이동.

*회원 웹 기능 -> 등록*

회원가입 창에서 이름을 쓰고 등록을 누르면,
MemberForm 클래스의 멤버변수 name과 
resources/templates/members/createMemberForm 에 있는, name이 매칭되서 들어옴.
들어올 때, post방식으로 들어와서
@PostMapping에 걸림.
member에 저장을 하고, memberService의 join에서 가입을 시킨 후,
return 값인 redirect:/ 를 타고 홈 화면으로 다시 돌아오게 됨.

Mapping에서 url은 동일하지만, post냐 Get이냐에 따라서 달라짐
Get은 보통 조회, 직접 url쳐서 들어올 수 있음
Post는 데이터 등록

*회원 웹 기능 -> 조회*

home.html에서 목록을 누르면, /members로 이동
@GetMapping("/members") -> 에서 mapping이 되고, 
members에 저장된 모든 멤버를 findMembers를 이용해 List에 저장후, model에 넣기
return 값인 members/memberList.html로 이동
```
<tr th:each="member : ${members}">
    <td th:text="${member.id}"></td>
    <td th:text="${member.name}"></td>
</tr>
```
위 코드에서 모든 member들을 돌면서 id와 name을 출력

회원 목록을 java에 저장하기 때문에, 껐다가 키면 회원 목록이 없어진다.
그러므로 계속 저장을 하려면, file이나 db에 저장을 해야함

*스프링 DB 접근 기술*

터미널에서 ./h2.sh를 실행하면 자꾸 오류가 떠서, 
윈도우와 wsl간에 환경변수를 공유할 수 있게 해주는 방법을 사용해 
echo $JAVA_HOME은 동일한 위치로 띄웠는데, 
java -version을 하면, 자꾸 openJDK 설치한 것이 떠서 그런지

vi h2.sh 파일에서 java 명령어가 있는데, 자꾸 에러가 뜬다. 해결 못함.
https://tjddnjs.tistory.com/145

일단, cmd에서 h2.bat으로 실행시켜서
cd ../../Workspace/H2/bin
처음 생성시, jdbc:h2:~/test 이걸로 연결시키면,
 ( ~/test  -> 홈에 있는 test폴더 )
홈에서 test.mv.db 파일이 생성된 것을 확인.

생성 이후 부터는 jdbc:h2:tcp://localhost/~/test 로 접속 
소켓으로 접근 하는 것 -> 그래야 여러군데에서 접근가능

---궁금한 점---
근데 여기서 jdbc:h2:~/test 로 접속하면 무슨 차이인지??

접속해서 기본 table 생성
```
drop table if exists member CASCADE;
create table member
(
 id bigint generated by default as identity,
 name varchar(255),
 primary key (id)
);
```
bigint -> Java의 Long 타입
generated by default as identity -> null값, 값을 세팅하지 않고 insert하면 DB가 자동으로 id값을 채워준다.
MemoryMemberRepository도 id값이 1씩 증가되는 것과 같은 원리, 맞춘 것

테이블 관리를 위해 sql/ddl.sql 파일, 폴더를 이용해 관리

DB 끄면 안됨. 연결 끊김

*순수 Jdbc*

자바는 DB랑 붙으려면 jdbc가 있어야 한다
implementation 'org.springframework.boot:spring-boot-starter-jdbc'

스프링 부트 데이터베이스 연결 설정
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa

JdbcMemberRepository(dataSource) 생성자의 인자에 넣는 dataSource는 DB와 연결해주는 
(?? 이해 잘 안됨)DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션
정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어둔다. 그래서 DI를 받을 수 있다.

<!-- https://bkim.tistory.com/22 -->
Spring boot 2.1 부터는 bean definition overriding이 false이므로, (@Controller와 중복되서 그런듯)
application파일에 아래 코드를 추가해줘야 한다.
```
spring.main.allow-bean-definition-overriding: true
```

SpringConfig 클래스의 memberRepository를 MemoryMemberRepository가 아닌,
JdbcMemberRepository로만 바꿔주면 h2로 만든 DB인
jdbc:h2:tcp://localhost/~/test 로 접근해서 사용가능.

![](스프링%20설정%20이미지,%20jdbc로%20저장소%20변경.png)

개방-폐쇄 원칙(OCP, Open-Closed Principle)
확장에는 열려있고, 수정, 변경에는 닫혀있다.
스프링의 DI (Dependencies Injection)을 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현
클래스를 변경할 수 있다

*스프링 통합 테스트*
원래는 JVM안에서만 끝나는 건데, DB까지 연결해서 테스트 하기

원래는 test에서만 작동하니, beforeEach에서 각각의 테스트 전에 객체를 직접생성해서 사용하였는데,
이제는 스프링 컨테이너에 객체(MemberService, MemberRepository)를 달라고 함
따라서, @BeforeEach도 필요없다.
스프링 컨테이너에서 객체를 받기 위해서 @Autowired 어노테이션 사용?

Test는 연속해서 할 수 있어야 한다.
하지만, 회원가입() 에서 같은 이름으로 연속으로 test하게 된다면, 오류가 날 수 밖에 없다.

하지만, @Transaction 이란 어노테이션을 붙여주면, 시작할때 transaction을 먼저 실행하고
join한 멤버를 insert쿼리하고 다 넣은 다음에, 롤백을 해준다. DB에 넣었던 데이터가 지워짐. 그래서 연속Test 가능. -> DB봐도 회원가입된 사람이 없게된다.

그래서 @Transaction 때문에, afterEach로 테스트한 것들을 다 지워주는 코드가 필요가 없는 것이다. 
따라서, @afterEach도 필요없다.

통합 테스트 : @SpringBootTest 진짜 스프링을 띄워서 테스트를 하는 것. 
통합 테스트는 스프링 띄우고 자바 띄우고 시간이 오래걸리지만,

단위 테스트 : 원래 test는 자바코드로만 진행
단위 테스트는 자바만 띄우면 되니까 매우 짧게 걸림
단위 테스트처럼 짧게 쪼개서 사용하는걸 권장.

*스프링 JdbcTemplate*
순수 Jdbc와 동일한 환경설정 / (Jdbc -> JdbcTemplate) 반복코드를 대부분 제거해줌, SQL은 직접 작성

생성자가 딱1개면(2개면 안됨), 스프링 빈으로 등록되면 @Autowired 생략가능

스프링 빈이 자동으로 datasource를 injection 해줌

DB까지 연동해서 test로 테스트하기

*JPA*
JPA는 객체랑 ORM(Object Relational Mapping)기술 사용 -> 객체, table을 mapping 해줌
@Entitiy -> 자바가 관리하는 Entity가 됨

@Id -> PK(Primary Key)를 Id라고 표시해주기
@GeneratedValue(strategy = GenerationType.IDENTITY)
위에서 만든 insert할때 id가 자동생성되는 것을 IDENTITY라고 부름, 표시해주기

스프링 부트가 자동으로 EntityManager라는걸 생성해줌, 현재 데이터베이스와 연결해서. 만들어준걸 injection받으면 됨

persist 영속하다, 영구저장하다
em.persist(member); -> jpa가 insert쿼리 만들어서 집어넣고, member.setid까지 다 해줌

findByName에서는 jpql이라는 객체지향 쿼리언어를 써야한다.
원래는 table단위로 쿼리를 날리는데, Entity(Member)를 대상으로 쿼리를 날리면 sql로 번역이되서 사용된다.
select m from Member m -> select m 은 객체 자체를 select하는 것, from Member (as) m 생략
원래는 select * or m.id 이렇게 선택하는데, 객체 자체를 select함 / 그리고 mapping해줘야 하는데 그걸 생략할 수 있음

jpa는 항상 @Transactional 안에서 실행해야 한다. (롤백) / test라도 @Commit은 DB에 반영됨
jpa는 test의 join 들어올 때, Transactional 안에서 실행 되어야 한다.
-> test 실행시 H2 데이터베이스 꼭 켜놓고 실행

jpa는 인터페이스이고 Hibernate가 구현

*스프링 데이터 JPA*
스프링 데이터 JPA는 JPA를 편리하게 사용하도록 도와주는 기술, JPA를 먼저 알아야 함.

interface는 다중 상속 가능, interface끼리 받을땐 extends 사용

interface만 생성하고 구현은 안해도 됨.
스프링 데이터 JPA가 JpaRepository를 받고 있으면, 구현체를 자동으로 만들어줌.
내가 스프링 빈에 등록하는게 아니라, 자동으로 등록해줌

SpringConfig 클래스
MemberRepository에 스프링 데이터 JPA가 구현체를 만들어준 거를 자동으로 등록해줌 injection 해줌

스프링 컨테이너에서 memberRepository를 찾는다. 위에서 자동 등록되었기 때문에 그걸 가져다 사용.

JpaRepository를 들어가보면, findById, findByAll같은 메소드들이 이미 구현이 되어있음. 그걸 가져다 쓰는 것.

findByName은 공통으로 만들 수 없으므로, 구현해주기
주문번호로 찾아라, 이름으로 찾으라해도 username일수도 name일수도 있어서 다 다르므로 공통되게 구현해놓지 못하는 것.

findByName처럼 인터페이스만으로 구현이 끝난 것. By뒤의 이름을 가지고 사용함

*AOP가 필요한 상황*
모든 메소드의 호출 시간을 측정하고 싶다면?
회원 가입 시간, 회원 조회 시간을 측정하고 싶다면?
1000개가 있다면, 일일히 다 하기도 시간이 너무 오래걸림
-> 스프링 컨테이너의 메소드마다 시간 측정 로직을 하나씩 다 붙이는 것이 너무 비효율적.

공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern)

문제
회원가입, 회원 조회에 시간을 측정하는 기능은 핵심 관심 사항이 아니다.
시간을 측정하는 로직은 공통 관심 사항이다.
시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞여서 유지보수가 어렵다.
시간을 측정하는 로직을 별도의 공통 로직으로 만들기 매우 어렵다.
시간을 측정하는 로직을 변경할 때 모든 로직을 찾아가면서 변경해야 한다.

*AOP 적용*
하나씩 붙이지 않고,
공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern) 분리 를 해서
시간 측정 로직(공통 관심 사항)을 하나만 공통으로 만들고 원하는 곳에 적용하기.

@Aspect를 써줘야 AOP로 사용가능
joinPoint.proceed() -> 다음 메소드 실행됨

@Component로 등록해줘도 되지만, 
SpringConfig클래스에 직접 등록해서 쓰는게 좋음, 인지하기도 좋음
```
@Bean
public TimeTraceAop TimeTraceAop() {
    return new TimeTraceAop();
}
```

@Around -> 그림에 나온대로 TimeTraceAop를 따로 만들고, 원하는 곳에 적용할 때, 적용할 곳을 지정해주는 어노테이션

@Around("execution(* hello.hellospring..*(..))")
hello.hellospring -> 패키지명 / * -> 클래스명 / () -> 인자 타입 지정

적용하면, start -> MemberController, MemberService, Jparepository 순서대로 적용됨

핵심 관심 사항을 깔끔하게 유지할 수 있다.
변경이 필요하면 이 로직만 변경하면 된다.
원하는 적용 대상을 선택할 수 있다.